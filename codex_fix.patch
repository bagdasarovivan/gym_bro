diff --git a/fitness_tracker.py b/fitness_tracker.py
index 0acc8d40414a708d02bd13ef2f46851291e85efb..caabd453075f045f99d6a6ceb7b25d684902fa41 100644
--- a/fitness_tracker.py
+++ b/fitness_tracker.py
@@ -1,38 +1,39 @@
 import streamlit as st
 import calendar
-import sqlite3
 import pandas as pd
 import matplotlib.pyplot as plt
 from datetime import date, timedelta
 import time
 import json
 import hashlib
 import re
 import os
+from contextlib import contextmanager
 import psycopg2
 import psycopg2.extras
+from psycopg2 import OperationalError, InterfaceError
 from pathlib import Path
 import streamlit.components.v1 as components
 import uuid
 
 # =========================
 # CONFIG / DEBUG
 # =========================
 DEBUG = False
 try:
     DEBUG = bool(st.secrets.get("DEBUG", False))
 except Exception:
     DEBUG = False
 
 
 def dbg(msg: str):
     if DEBUG:
         st.caption(msg)
 
 
 start_total = time.time()
 
 BASE_DIR = Path(__file__).resolve().parent
 
 DB_PATH = str((BASE_DIR / "fitness.db").resolve())
 
@@ -201,350 +202,435 @@ def safe_image(rel_path: str | None, width: int | None = None):
     if not p.exists() or not p.is_file():
         return
     try:
         st.image(str(p), width=width)
     except Exception:
         return
 
 
 def read_sets_from_widgets(ns: str, sets_count: int, mode: str) -> list[dict]:
     rows: list[dict] = []
     if mode == "time":
         for i in range(1, sets_count + 1):
             t = int(st.session_state.get(f"{ns}_t_{i}", 0))
             rows.append({"time_sec": t})
     else:
         for i in range(1, sets_count + 1):
             w = int(st.session_state.get(f"{ns}_w_{i}", 0))
             r = int(st.session_state.get(f"{ns}_r_{i}", 0))
             rows.append({"weight": w, "reps": r})
     return rows
 
 
 # =========================
 # DB HELPERS
 # =========================
-@st.cache_resource
-def get_conn():
+def _new_conn():
     db_url = st.secrets.get("DATABASE_URL")
     if not db_url:
         raise RuntimeError("–ù–µ—Ç DATABASE_URL –≤ st.secrets (Supabase –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω)")
     conn = psycopg2.connect(db_url)
-    conn.autocommit = True
+    conn.autocommit = False
+    return conn
+
+
+@st.cache_resource
+def get_conn():
+    return _new_conn()
+
+
+def get_live_conn():
+    conn = get_conn()
+    if conn.closed:
+        get_conn.clear()
+        return get_conn()
+    try:
+        with conn.cursor() as cur:
+            cur.execute("SELECT 1")
+        conn.commit()
+    except (OperationalError, InterfaceError):
+        get_conn.clear()
+        conn = get_conn()
     return conn
 
 def init_db(conn):
     with conn.cursor() as cur:
         cur.execute(
             """
             CREATE TABLE IF NOT EXISTS exercises (
                 id BIGSERIAL PRIMARY KEY,
                 name TEXT NOT NULL UNIQUE
             );
             """
         )
 
         cur.execute(
             """
             CREATE TABLE IF NOT EXISTS workouts (
                 id BIGSERIAL PRIMARY KEY,
                 workout_date DATE NOT NULL,
                 exercise_id BIGINT NOT NULL REFERENCES exercises(id) ON DELETE CASCADE
             );
             """
         )
 
         cur.execute(
             """
             CREATE TABLE IF NOT EXISTS sets (
                 id BIGSERIAL PRIMARY KEY,
                 workout_id BIGINT NOT NULL REFERENCES workouts(id) ON DELETE CASCADE,
                 set_no INT NOT NULL,
                 weight DOUBLE PRECISION NOT NULL,
                 reps INT NOT NULL,
                 time_sec INT
             );
             """
         )
 
         cur.execute("CREATE INDEX IF NOT EXISTS idx_workouts_date ON workouts(workout_date);")
         cur.execute("CREATE INDEX IF NOT EXISTS idx_workouts_exercise ON workouts(exercise_id);")
         cur.execute("CREATE INDEX IF NOT EXISTS idx_sets_workout ON sets(workout_id);")
+        cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS uq_sets_workout_setno ON sets(workout_id, set_no);")
+        cur.execute(
+            """
+            CREATE TABLE IF NOT EXISTS app_meta (
+                key TEXT PRIMARY KEY,
+                value TEXT NOT NULL
+            );
+            """
+        )
 
     conn.commit()
 
 
 def _seed_hash(names: list[str]) -> str:
     normalized = sorted([n.strip() for n in names if n and n.strip()])
     payload = json.dumps(normalized, ensure_ascii=False).encode("utf-8")
     return hashlib.sha256(payload).hexdigest()
 
 
 def seed_exercises_hashed(conn, names: list[str]):
     """
     Seed only when the seed list changes (per session).
     """
     h = _seed_hash(names)
-    key = "_seed_hash_exercises"
-    if st.session_state.get(key) == h:
-        return
 
     clean = [(n.strip(),) for n in names if n and n.strip()]
     if clean:
         with conn.cursor() as cur:
+            cur.execute("SELECT value FROM app_meta WHERE key = %s", ("seed_hash_exercises",))
+            row = cur.fetchone()
+            if row and str(row[0]) == h:
+                return
+
             cur.executemany(
                 "INSERT INTO exercises(name) VALUES(%s) ON CONFLICT (name) DO NOTHING",
                 clean,
             )
+            cur.execute(
+                """
+                INSERT INTO app_meta(key, value)
+                VALUES(%s, %s)
+                ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value
+                """,
+                ("seed_hash_exercises", h),
+            )
         conn.commit()
-        st.session_state[key] = h
         get_exercises_df.clear()
 
+
+@st.cache_resource
+def ensure_db_ready():
+    conn = get_conn()
+    init_db(conn)
+    seed_exercises_hashed(conn, SEED_EXERCISES)
+
 # =========================
 # CACHED READS
 # =========================
 @st.cache_data(ttl=600)
 def get_exercises_df() -> pd.DataFrame:
-    conn = get_conn()
+    conn = get_live_conn()
     return pd.read_sql_query("SELECT id, name FROM exercises ORDER BY name", conn)
 
 
 @st.cache_data(ttl=600)
 def get_month_daily_df(year: int, month: int) -> pd.DataFrame:
-    conn = get_conn()
+    conn = get_live_conn()
     ym_start = f"{year:04d}-{month:02d}-01"
     last_day = calendar.monthrange(year, month)[1]
     ym_end = f"{year:04d}-{month:02d}-{last_day:02d}"
     return pd.read_sql_query(
     """
     SELECT workout_date, COUNT(*) AS entries
     FROM workouts
     WHERE workout_date BETWEEN %s AND %s
     GROUP BY workout_date
     """,
     conn,
     params=(ym_start, ym_end),
     )
 
 
 @st.cache_data(ttl=300)
 def get_history_compact(exercise: str | None, d_from: str, d_to: str) -> pd.DataFrame:
-    conn = get_conn()
+    conn = get_live_conn()
 
     base = """
         SELECT
             w.id AS workout_id,
             w.workout_date,
             e.name AS exercise,
             string_agg(
                 CASE
                     WHEN s.time_sec IS NOT NULL AND s.time_sec > 0 THEN (s.time_sec::text || 's')
                     ELSE (s.weight::int::text || '√ó' || s.reps::text)
                 END,
                 ' | '
                 ORDER BY s.set_no
             ) AS sets
         FROM workouts w
         JOIN exercises e ON e.id = w.exercise_id
         JOIN sets s ON s.workout_id = w.id
         WHERE w.workout_date BETWEEN %s AND %s
         {ex_filter}
         GROUP BY w.id, w.workout_date, e.name
         ORDER BY w.workout_date DESC, w.id DESC
     """
 
     if exercise and exercise != "All":
         q = base.format(ex_filter="AND e.name = %s")
         return pd.read_sql_query(q, conn, params=(d_from, d_to, exercise))
 
     q = base.format(ex_filter="")
     return pd.read_sql_query(q, conn, params=(d_from, d_to))
 
 
 @st.cache_data(ttl=300)
-def get_exercise_sets_for_progress(exercise_name: str) -> pd.DataFrame:
-    conn = get_conn()
+def get_progress_daily(exercise_name: str) -> pd.DataFrame:
+    conn = get_live_conn()
     return pd.read_sql_query(
         """
         SELECT
             w.workout_date,
-            s.weight,
-            s.reps
+            MAX(s.weight * (1 + (s.reps / 30.0))) AS est_1rm,
+            MAX(s.weight) AS top_weight
         FROM workouts w
         JOIN exercises e ON e.id = w.exercise_id
         JOIN sets s ON s.workout_id = w.id
         WHERE e.name = %s
         AND (s.time_sec IS NULL OR s.time_sec = 0)
         AND s.weight > 0 AND s.reps > 0
-        ORDER BY w.workout_date ASC, w.id ASC, s.set_no ASC
+        GROUP BY w.workout_date
+        ORDER BY w.workout_date ASC
         """,
         conn,
         params=(exercise_name,),
     )
 
 
+@st.cache_data(ttl=300)
+def get_history_date_bounds() -> tuple[date | None, date | None]:
+    conn = get_live_conn()
+    with conn.cursor() as cur:
+        cur.execute("SELECT MIN(workout_date), MAX(workout_date) FROM workouts")
+        row = cur.fetchone()
+    if not row:
+        return (None, None)
+    return (row[0], row[1])
+
+
 def clear_cache_after_write():
     get_exercises_df.clear()
     get_month_daily_df.clear()
     get_history_compact.clear()
-    get_exercise_sets_for_progress.clear()
+    get_progress_daily.clear()
+    get_history_date_bounds.clear()
+    get_workout_for_edit_cached.clear()
 
 
 # =========================
 # WRITES
 # =========================
 def upsert_exercise(conn, name: str) -> int:
     name = name.strip()
     if not name:
         raise ValueError("Empty exercise name")
 
     with conn.cursor() as cur:
         cur.execute(
-            "INSERT INTO exercises(name) VALUES(%s) ON CONFLICT (name) DO NOTHING",
+            """
+            INSERT INTO exercises(name) VALUES(%s)
+            ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
+            RETURNING id
+            """,
             (name,),
         )
-        cur.execute("SELECT id FROM exercises WHERE name = %s", (name,))
         row = cur.fetchone()
 
     conn.commit()
 
     if not row:
         raise RuntimeError("Failed to fetch exercise id")
     return int(row[0])
 
 def insert_workout(conn, workout_date: str, exercise_id: int, sets_rows: list[dict]):
     with conn.cursor() as cur:
         cur.execute(
             "INSERT INTO workouts(workout_date, exercise_id) VALUES(%s, %s) RETURNING id",
             (workout_date, exercise_id),
         )
         workout_id = int(cur.fetchone()[0])
 
         payload: list[tuple] = []
         for i, s in enumerate(sets_rows, start=1):
             payload.append(
                 (
                     workout_id,
                     i,
                     float(s.get("weight", 0)),
                     int(s.get("reps", 0)),
                     int(s["time_sec"]) if s.get("time_sec") is not None else None,
                 )
             )
 
         cur.executemany(
             """
             INSERT INTO sets(workout_id, set_no, weight, reps, time_sec)
             VALUES(%s, %s, %s, %s, %s)
             """,
             payload,
         )
 
     conn.commit()
     clear_cache_after_write()
 
 def delete_workout(conn, workout_id: int):
     with conn.cursor() as cur:
         cur.execute("DELETE FROM workouts WHERE id = %s", (workout_id,))
     conn.commit()
     clear_cache_after_write()
 
 
 def get_workout_for_edit(conn, workout_id: int) -> dict:
-    with conn.cursor() as cur:
-        cur.execute("""
-            SELECT w.id, w.workout_date, e.name
+    with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
+        cur.execute(
+            """
+            SELECT
+                w.id AS workout_id,
+                w.workout_date,
+                e.name AS exercise,
+                COALESCE(
+                    json_agg(
+                        json_build_object(
+                            'set_no', s.set_no,
+                            'weight', s.weight,
+                            'reps', s.reps,
+                            'time_sec', s.time_sec
+                        )
+                        ORDER BY s.set_no
+                    ) FILTER (WHERE s.id IS NOT NULL),
+                    '[]'::json
+                ) AS sets
             FROM workouts w
             JOIN exercises e ON e.id = w.exercise_id
+            LEFT JOIN sets s ON s.workout_id = w.id
             WHERE w.id = %s
-        """, (workout_id,))
+            GROUP BY w.id, w.workout_date, e.name
+            """,
+            (workout_id,),
+        )
         row = cur.fetchone()
 
     if not row:
         raise ValueError("Workout not found")
 
-    sets = pd.read_sql_query("""
-        SELECT set_no, weight, reps, time_sec
-        FROM sets
-        WHERE workout_id = %s
-        ORDER BY set_no ASC
-    """, conn, params=(workout_id,))
+    sets_df = pd.DataFrame(row["sets"])
+    return {
+        "workout_id": int(row["workout_id"]),
+        "workout_date": str(row["workout_date"]),
+        "exercise": str(row["exercise"]),
+        "sets": sets_df,
+    }
+
 
-    return {"workout_id": int(row[0]), "workout_date": str(row[1]), "exercise": str(row[2]), "sets": sets}
+@st.cache_data(ttl=300)
+def get_workout_for_edit_cached(workout_id: int) -> dict:
+    conn = get_live_conn()
+    return get_workout_for_edit(conn, workout_id)
 
 # =========================
 # COPY TO CLIPBOARD (JS)
 # =========================
 def copy_to_clipboard_button(text: str, label: str = "üìã Copy", key: str = "copy_btn"):
     js_text = json.dumps(text, ensure_ascii=False)
     js_key = json.dumps(key, ensure_ascii=False)
     js_status = json.dumps(key + "_status", ensure_ascii=False)
 
     html = f"""
     <div style="margin: 8px 0;">
       <button id="{key}" style="
         padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.2);
         background: rgba(255,255,255,0.08); color: white; cursor: pointer; font-size: 14px;">
         {label}
       </button>
       <span id="{key}_status" style="margin-left:10px; opacity:.8; font-size: 13px;"></span>
     </div>
 
     <script>
       const btn = document.getElementById({js_key});
       const status = document.getElementById({js_status});
 
       btn.onclick = async () => {{
         try {{
           await navigator.clipboard.writeText({js_text});
           status.textContent = "Copied ‚úÖ";
           setTimeout(() => status.textContent = "", 1200);
         }} catch (e) {{
           status.textContent = "Copy failed (browser blocked)";
           setTimeout(() => status.textContent = "", 1800);
         }}
       }};
     </script>
     """
     components.html(html, height=60)
 
 # =========================
 # HEADER
 # =========================
 col1, col2 = st.columns([1, 6])
 with col1:
     safe_image("images/gymbro_logo.png", width=90)
 with col2:
     st.markdown("<h1 style='margin:0'>Gym BRO</h1>", unsafe_allow_html=True)
 
 # =========================
 # INIT DB + SEED
 # =========================
 try:
-    conn = get_conn()
-    init_db(conn)
-    seed_exercises_hashed(conn, SEED_EXERCISES)
+    conn = get_live_conn()
+    ensure_db_ready()
 except Exception as e:
     st.error(f"DB connect failed: {e}")
     st.stop()    
 
 tab_add, tab_history, tab_progress = st.tabs(["‚ûï Add workout", "üìú History", "üìà Progress"])
 
 # =========================
 # TAB: Add workout
 # =========================
 with tab_add:
     st.subheader("Add workout")
 
     workout_date = st.date_input(
         "üìÖ Date",
         value=date.today(),
         min_value=date(2020, 1, 1),
         max_value=date.today(),
         key="workout_date",
     )
 
     ex_df = get_exercises_df()
     ex_names = ex_df["name"].tolist()
 
     q = st.text_input("Search exercise", "", key="search_ex")
     filtered = [x for x in ex_names if q.lower() in x.lower()] if q else ex_names
@@ -606,51 +692,50 @@ with tab_add:
                     st.session_state[key_w] = int(s.get("weight", 0) or 0)
                 if key_r not in st.session_state:
                     st.session_state[key_r] = int(s.get("reps", 0) or 0)
 
                 with c1:
                     w = st.selectbox(
                         f"Set {idx} ‚Äî Weight (kg)",
                         profile["weight_options"],
                         key=key_w,
                     )
                 with c2:
                     r = st.selectbox(
                         f"Set {idx} ‚Äî Reps",
                         profile["reps_options"],
                         key=key_r,
                     )
 
                 sets_rows.append({"weight": int(w), "reps": int(r)})
 
         # Apply sets button INSIDE the box
         apply_btn = st.button("‚úÖ Apply sets", use_container_width=False)
 
     # Apply action: just sync sets_key with what is currently selected
     if apply_btn:
         st.session_state[sets_key] = sets_rows
-        st.rerun()
 
     # buttons BELOW the box (–∫–∞–∫ –Ω–∞ —Ç–≤–æ—ë–º —Å–∫—Ä–∏–Ω–µ)
     st.markdown('<div style="height:8px"></div>', unsafe_allow_html=True)
     c1, c2 = st.columns([1, 1], gap="small")
 
     add_btn = c1.button("‚ûï Add set", use_container_width=True)
     remove_btn = c2.button(
         "‚ûñ Remove set",
         use_container_width=True,
         disabled=len(st.session_state[sets_key]) <= 1,
     )
 
     if add_btn:
         # —Ñ–∏–∫—Å–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è (—Ç–æ, —á—Ç–æ —Ä–µ–∞–ª—å–Ω–æ –≤ —Å–µ–ª–µ–∫—Ç–∞—Ö)
         st.session_state[sets_key] = sets_rows
 
         if mode == "time":
             last_val = int(sets_rows[-1].get("time_sec", 0))
             st.session_state[sets_key].append({"time_sec": last_val})
             new_idx = len(st.session_state[sets_key])
             st.session_state[f"{ns}_t_{new_idx}"] = last_val
         else:
             last_w = int(sets_rows[-1].get("weight", 0))
             last_r = int(sets_rows[-1].get("reps", 0))
             st.session_state[sets_key].append({"weight": last_w, "reps": last_r})
@@ -677,103 +762,104 @@ with tab_add:
     current_sets = st.session_state[sets_key]
 
     # (–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) –ø–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ—Å—Ç—ã–º —Ç–µ–∫—Å—Ç–æ–º:
     if mode == "time":
         txt = " | ".join([f"{int(s.get('time_sec', 0))}s" for s in current_sets])
     else:
         txt = " | ".join([f"{int(s.get('weight', 0))}√ó{int(s.get('reps', 0))}" for s in current_sets])
     st.caption(txt)
 
     # =========================
     # SAVE WORKOUT
     # =========================
     if st.button("üíæ Save workout", key=f"{ns}_save_btn"):
         try:
             current_sets = st.session_state[sets_key]
 
             if mode == "time":
                 cleaned = [s for s in current_sets if int(s.get("time_sec", 0)) > 0]
                 normalized = [{"weight": 0, "reps": 0, "time_sec": int(s["time_sec"])} for s in cleaned]
             else:
                 cleaned = [s for s in current_sets if int(s.get("weight", 0)) > 0 and int(s.get("reps", 0)) > 0]
                 normalized = [{"weight": int(s["weight"]), "reps": int(s["reps"]), "time_sec": None} for s in cleaned]
 
             if not normalized:
                 st.error("Add at least one filled set.")
-                st.stop()
+                normalized = []
 
-            ex_id = upsert_exercise(conn, exercise_name)
-            insert_workout(conn, str(workout_date), ex_id, normalized)
+            if not normalized:
+                pass
+            else:
+                ex_id = upsert_exercise(conn, exercise_name)
+                insert_workout(conn, str(workout_date), ex_id, normalized)
 
-            st.success("Saved ‚úÖ")
+                st.success("Saved ‚úÖ")
 
-            # reset state and widget keys
-            st.session_state[sets_key] = [{"time_sec": 0}] if mode == "time" else [{"weight": 0, "reps": 0}]
-            for i in range(1, 60):
-                st.session_state.pop(f"{ns}_w_{i}", None)
-                st.session_state.pop(f"{ns}_r_{i}", None)
-                st.session_state.pop(f"{ns}_t_{i}", None)
+                # reset state and widget keys
+                st.session_state[sets_key] = [{"time_sec": 0}] if mode == "time" else [{"weight": 0, "reps": 0}]
+                for i in range(1, 60):
+                    st.session_state.pop(f"{ns}_w_{i}", None)
+                    st.session_state.pop(f"{ns}_r_{i}", None)
+                    st.session_state.pop(f"{ns}_t_{i}", None)
 
-            st.rerun()
+                st.rerun()
 
         except Exception as e:
             st.error(f"Save failed: {e}")
 
 
 
 # =========================
 # TAB: History
 # =========================
 
 with tab_history:
     st.subheader("History")
 
     # --- Filters ---
     ex_df = get_exercises_df()
     ex_list = ["All"] + ex_df["name"].tolist()
     c1, c2, c3 = st.columns([2, 2, 2])
 
     with c1:
         ex_filter = st.selectbox("Exercise", ex_list, index=0, key="hist_ex_filter")
 
-    with conn.cursor() as cur:
-        cur.execute("SELECT MIN(workout_date), MAX(workout_date) FROM workouts")
-        row = cur.fetchone()
-
-    if not row or row[0] is None:
+    dmin, dmax = get_history_date_bounds()
+    if dmin is None:
         st.info("No workouts yet.")
         st.stop()
-
-    dmin = row[0]
-    dmax = row[1]
     default_from = max(dmin, dmax - timedelta(days=30))
 
     with c2:
         d_from = st.date_input("From", value=default_from, min_value=dmin, max_value=dmax, key="hist_from")
     with c3:
         d_to = st.date_input("To", value=dmax, min_value=dmin, max_value=dmax, key="hist_to")
 
+    if d_from > d_to:
+        st.warning("'From' –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ 'To'.")
+        st.stop()
+
     t0 = time.time()
     view = get_history_compact(ex_filter, str(d_from), str(d_to))
     dbg(f"history_compact: {time.time() - t0:.3f}s | rows={len(view)}")
 
     if view.empty:
         st.info("No records for current filters.")
         st.stop()
 
     st.markdown("---")
 
     # --- Day groups (custom accordion + copy button) ---
     for day, day_df in view.groupby("workout_date", sort=False):
         day_df = day_df.sort_values("workout_id", ascending=False)
 
         # Text for copying ONLY this day
         lines = [f"üìÖ {day} ¬∑ {len(day_df)} exercises"]
         for _, rr in day_df.iterrows():
             sets = ", ".join([s.strip() for s in str(rr["sets"]).split("|")])
             lines.append(f"{rr['exercise']}: {sets}")
         day_text = "\n".join(lines)
 
         # Safe keys
         day_id = re.sub(r"[^0-9A-Za-z_]+", "_", str(day))
         open_key = f"open_day_{day_id}"
         toggle_key = f"toggle_day_{day_id}"
@@ -795,52 +881,52 @@ with tab_history:
                 use_container_width=True,
             ):
                 st.session_state[open_key] = not st.session_state[open_key]
                 st.rerun()
 
         with right_col:
             copy_to_clipboard_button(day_text, key=copy_key, label="üìã Copy")
 
         # Expanded content
         if st.session_state[open_key]:
             for _, r in day_df.iterrows():
                 workout_id = int(r["workout_id"])
 
                 l, m, rr = st.columns([6, 2, 2], vertical_alignment="center")
 
                 with l:
                     st.markdown(f"**{r['exercise']}**")
                     chips = "".join(
                         [f'<span class="set-chip">{s.strip()}</span>' for s in str(r["sets"]).split("|")]
                     )
                     st.markdown(f'<div class="sets-wrap">{chips}</div>', unsafe_allow_html=True)
 
                 with m:
                     pop = st.popover("‚úèÔ∏è Edit", use_container_width=True)
                     with pop:
-                        st.info("Edit UI –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∑–∂–µ).")
-                        data = get_workout_for_edit(conn, workout_id)
+                        st.info("Details only: —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ.")
+                        data = get_workout_for_edit_cached(workout_id)
                         st.write(
                             {
                                 "date": data["workout_date"],
                                 "exercise": data["exercise"],
                                 "sets_rows": len(data["sets"]),
                             }
                         )
 
                 with rr:
                     pop = st.popover("üóë Delete", use_container_width=True)
                     with pop:
                         st.write("Delete this entry?")
                         confirm = st.checkbox("Confirm", key=f"confirm_{workout_id}")
                         if st.button("Delete", key=f"del_{workout_id}", disabled=not confirm):
                             delete_workout(conn, workout_id)
                             st.success("Deleted ‚úÖ")
                             st.rerun()
 
             st.markdown("---")
 
 # =========================
 # TAB: Progress
 # =========================
 with tab_progress:
     st.subheader("Progress")
@@ -916,58 +1002,52 @@ with tab_progress:
                 trained = d in entries_map
                 cls = "cal-day cal-trained" if trained else "cal-day"
                 cnt = (
                     f'<span class="cal-count">{entries_map[d]} –∑–∞–ø–∏—Å–∏</span>'
                     if trained
                     else '<span class="cal-count">&nbsp;</span>'
                 )
                 html.append(f'<td class="{cls}">{d}{cnt}</td>')
         html.append("</tr>")
 
     html.append("</tbody></table></div>")
     st.markdown("".join(html), unsafe_allow_html=True)
 
     st.divider()
     st.markdown("## üìà Exercise progress")
 
     ex_df = get_exercises_df()
     ex_names = ex_df["name"].tolist()
     if not ex_names:
         st.info("No exercises.")
         st.stop()
 
     ex = st.selectbox("Exercise", ex_names, key="progress_exercise_select")
 
     t_p = time.time()
-    df = get_exercise_sets_for_progress(ex)
+    df = get_progress_daily(ex)
     dbg(f"progress_sets: {time.time() - t_p:.3f}s | rows={len(df)}")
 
     if df.empty:
         st.info("No weight+reps sets for this exercise yet.")
         st.stop()
 
     # Ensure datetime on x-axis
     df["workout_date"] = pd.to_datetime(df["workout_date"])
 
-    # Estimated 1RM
-    df["est_1rm"] = df["weight"] * (1 + (df["reps"] / 30.0))
-
-    best_1rm_by_day = df.groupby("workout_date", as_index=False)["est_1rm"].max()
-    top_w_by_day = df.groupby("workout_date", as_index=False)["weight"].max()
-
     fig, ax1 = plt.subplots()
-    ax1.plot(best_1rm_by_day["workout_date"], best_1rm_by_day["est_1rm"])
+    ax1.plot(df["workout_date"], df["est_1rm"])
     ax1.set_title(f"{ex} ‚Äî Estimated 1RM & Top weight by day")
     ax1.set_xlabel("Date")
     ax1.set_ylabel("Estimated 1RM")
     plt.xticks(rotation=45)
 
     ax2 = ax1.twinx()
-    ax2.plot(top_w_by_day["workout_date"], top_w_by_day["weight"])
+    ax2.plot(df["workout_date"], df["top_weight"])
     ax2.set_ylabel("Top weight (kg)")
 
     st.pyplot(fig)
     plt.close(fig)
 
     st.metric("üèÜ Best estimated 1RM", f"{float(df['est_1rm'].max()):.1f}")
 
-dbg(f"Render: {time.time() - start_total:.3f} sec")
\ No newline at end of file
+dbg(f"Render: {time.time() - start_total:.3f} sec")
